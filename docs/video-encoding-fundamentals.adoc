= Video Encoding Fundamentals

A primer for contributors on the concepts underpinning HLS video streaming.

== Containers vs Codecs

A *container* (MKV, MP4, MPEGTS, fMP4) is a wrapper that carries one or more streams -- video, audio, subtitles, and metadata. Changing the container is cheap: FFmpeg copies the compressed streams into a new wrapper without re-encoding (`-c copy`, called a *remux*).

A *codec* (H.264, H.265, AV1) is the compression algorithm applied to the raw video frames. Changing the codec requires decoding every frame and re-encoding it, which is orders of magnitude more expensive than a container change.

=== Common Containers

|===
| Container | Extension | Notes

| MKV (Matroska)
| `.mkv`
| Open format, supports virtually any codec combination. Common for stored media files

| MP4
| `.mp4`
| ISO base media file format. Universal browser/device compatibility

| MPEGTS
| `.ts`
| Transport stream for HLS. Carries H.264 + AAC. Each segment is independently decodable

| fMP4
| `.m4s` + `.mp4` init
| Fragmented MP4 for HLS. Required for AV1 and H.265 in HLS. Needs an initialization segment (`init.mp4`) containing codec parameters
|===

=== Common Codecs

|===
| Codec | Compression | Hardware Support | Notes

| H.264 (AVC)
| Baseline
| Universal (every GPU since ~2012)
| Default for maximum compatibility. Uses MPEGTS container in HLS

| H.265 (HEVC)
| ~40% better than H.264
| Broad (most GPUs since ~2016)
| Patent licensing complexity. Uses fMP4 container in HLS

| AV1
| ~30-50% better than H.264
| Growing (Intel Arc, NVIDIA Ada+, AMD RDNA3+)
| Royalty-free, Netflix uses for 30%+ of traffic in 2026. Uses fMP4 container in HLS
|===

== How HLS Works

HTTP Live Streaming (RFC 8216) delivers video as a sequence of small HTTP-downloadable files:

----
Master Playlist (master.m3u8)
    ├── Variant 1: 1080p (stream_1080p.m3u8)
    │       ├── segment0.ts
    │       ├── segment1.ts
    │       └── ...
    ├── Variant 2: 720p (stream_720p.m3u8)
    │       ├── segment0.ts
    │       └── ...
    └── Variant 3: 480p (stream_480p.m3u8)
            └── ...
----

1. The *master playlist* lists available quality variants with bandwidth and resolution
2. The client picks a variant based on network conditions
3. The *media playlist* lists the segments for that variant with their durations
4. The client downloads segments sequentially, switching variants adaptively

The container (MPEGTS vs fMP4) is a packaging detail -- the client sees segments regardless. fMP4 requires an additional initialization segment (`init.mp4`) containing decoder configuration.

== REMUX vs Transcode

The cost of streaming depends on whether the source codec matches what the client can play:

|===
| Mode | What FFmpeg Does | CPU Cost | When

| REMUX
| Repackages streams into HLS segments without re-encoding (`-c copy`)
| Near zero
| Source codec is client-compatible (e.g., H.264 source, client supports H.264)

| Partial Transcode
| Copies video, re-encodes audio only (`-c:v copy -c:a aac`)
| Low
| Video codec matches but audio needs conversion (e.g., FLAC audio to AAC)

| Full Transcode
| Decodes and re-encodes both video and audio
| High (GPU) or Very High (CPU)
| Source codec is incompatible (e.g., H.265 source, client only supports H.264)
|===

Hardware encoding (NVENC, QSV, AMF, VideoToolbox) makes full transcoding practical for real-time streaming. A single modern GPU can handle multiple simultaneous transcodes at speeds well above real-time.

== Adaptive Bitrate Streaming (ABR)

Adaptive Bitrate Streaming encodes the same source into multiple quality *renditions* (resolution + bitrate combinations) and lists them in the HLS master playlist. The client player monitors network throughput and buffer levels, switching between renditions mid-stream to maintain smooth playback.

=== When ABR Applies

ABR only applies when the transcode mode is `FULL_TRANSCODE` and the requested quality is `AUTO`. In this case, the `QualityLadderService` generates a set of renditions from the standard quality tiers:

|===
| Tier | Resolution | Video Bitrate | Audio Bitrate

| 1080p | 1920x1080 | 5 Mbps | 128 kbps
| 720p  | 1280x720  | 3 Mbps | 128 kbps
| 480p  | 854x480   | 1.5 Mbps | 96 kbps
| 360p  | 640x360   | 800 kbps | 64 kbps
|===

Tiers are filtered by the source resolution (no upscaling) and any client-declared constraints (`maxHeight`, `maxBitrate`). A 720p source produces at most 720p, 480p, and 360p variants.

=== Why Not REMUX or PARTIAL_TRANSCODE?

Both modes copy the video stream verbatim (`-c:v copy`). The video resolution and bitrate are fixed at the source values -- FFmpeg cannot downscale or re-rate a copied stream. ABR requires re-encoding, which is why it only applies to `FULL_TRANSCODE`.

=== Architecture: One FFmpeg per Variant

Each quality variant runs as a separate FFmpeg process writing segments to its own subdirectory:

----
session-{uuid}/
    ├── 1080p/
    │       ├── stream.m3u8
    │       ├── segment0.ts
    │       └── ...
    ├── 720p/
    │       ├── stream.m3u8
    │       └── ...
    └── master.m3u8
----

This keeps each process simple (single output) and allows independent lifecycle management -- a variant can be started, stopped, or restarted without affecting others.

=== FFmpeg Flags per Variant

Each variant's FFmpeg command includes:

* **Scale filter:** `-vf scale=-2:{height}` -- downscales video to the target height while auto-calculating width to preserve the source aspect ratio. The `-2` ensures the width is even (required by most codecs).
* **CBR/VBV rate control:**
** `-b:v {bitrate}` -- target video bitrate
** `-maxrate {bitrate}` -- VBV ceiling (same as target for CBR behavior)
** `-bufsize {bitrate x 2}` -- VBV buffer size, set to 2x the bitrate for tight rate control and predictable segment sizes

These flags apply to `FULL_TRANSCODE` only. `REMUX` and `PARTIAL_TRANSCODE` commands use `-c:v copy` and omit all scale/bitrate arguments.

== Why This Matters for Streamarr

The `TranscodeDecisionService` inspects the source file (via ffprobe) and the client's declared codec support to choose the cheapest path: REMUX when possible, partial transcode when only audio needs conversion, full transcode as a last resort. This decision is cached per session so seek operations reuse the same strategy.
